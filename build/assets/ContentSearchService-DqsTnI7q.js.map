{"version":3,"mappings":"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","names":["isValidEntry","entry","ContentSearchService","contentIndexData","fs","__vitePreload","indexPath","rawData","controller","timeoutId","response","fetchError","errorHandlingService","error","errorResult","cacheKey","promise","categories","category","subcategories","subcategory","maxIntensity","contentIndex","replacementThoughts","matchingEntries","type","prompts","query","results","queryLower","chunk","a","b","text","textLower","exactMatches","lengthBoost","cat","subs","contentSearchService"],"ignoreList":[],"sources":["../../src/services/ContentSearchService.ts"],"sourcesContent":["/**\n * ContentSearchService\n * Provides methods to query the content index for categories, subcategories,\n * and replacement thoughts. Integrates with the content-index.bin structure.\n * Enhanced with error handling and graceful degradation.\n */\n\nimport errorHandlingService from '../services/ErrorHandlingService';\n\ninterface ContentEntry {\n  category: string;\n  subcategories: string[];\n  summaryForVectorization: string;\n  miningPrompts: {\n    [key: string]: string[];\n  };\n  replacementThoughts: string[];\n  chunks?: Array<{\n    text: string;\n    metadata?: Record<string, any>;\n  }>;\n}\n\ninterface ContentIndex {\n  metadata: {\n    categories: string[];\n    subcategories: {\n      [category: string]: string[];\n    };\n    totalEntries?: number;\n    totalChunks?: number;\n  };\n  entries: ContentEntry[];\n  version: string;\n  timestamp: number;\n  fallback?: boolean;\n}\n\ninterface ErrorResult {\n  useFallback: boolean;\n  fallbackData: any;\n}\n\ninterface SearchResult {\n  text: string;\n  category: string;\n  subcategories: string[];\n  metadata?: Record<string, any>;\n  relevance: number;\n}\n\ninterface ContentStats {\n  version: string;\n  timestamp: number;\n  categories: number;\n  totalEntries?: number;\n  totalChunks?: number;\n  subcategoriesPerCategory: Array<{\n    category: string;\n    subcategories: number;\n  }>;\n}\n\nfunction isValidEntry(entry: any): entry is ContentEntry {\n  return entry && entry.category && Array.isArray(entry.subcategories) && entry.summaryForVectorization && entry.miningPrompts && Array.isArray(entry.replacementThoughts);\n}\n\nclass ContentSearchService {\n  private contentIndex: ContentIndex | null;\n  private isLoaded: boolean;\n  private loadingPromise: Promise<ContentIndex> | null;\n  private cache: Map<string, any>;\n\n  constructor() {\n    this.contentIndex = null;\n    this.isLoaded = false;\n    this.loadingPromise = null;\n    this.cache = new Map();\n  }\n\n  /**\n   * Load the content index from the binary file with enhanced error handling\n   */\n  async loadContentIndex(): Promise<ContentIndex> {\n    if (this.isLoaded && this.contentIndex) {\n      return this.contentIndex;\n    }\n\n    // Prevent multiple simultaneous loading attempts\n    if (this.loadingPromise) {\n      return this.loadingPromise;\n    }\n\n    this.loadingPromise = this._performLoad();\n    return this.loadingPromise;\n  }\n\n  private async _performLoad(): Promise<ContentIndex> {\n    try {\n      let contentIndexData: ContentIndex;\n      \n      // Check if we're in Node.js environment (for testing)\n      if (typeof window === 'undefined') {\n        // Node.js environment - read file directly\n        const fs = await import('fs');\n        const path = await import('path');\n        const indexPath = path.resolve('public/content/content-index.bin');\n        \n        if (fs.existsSync(indexPath)) {\n          const rawData = fs.readFileSync(indexPath, 'utf8');\n          contentIndexData = JSON.parse(rawData) as ContentIndex;\n        } else {\n          throw new Error('Content index file not found');\n        }\n      } else {\n        // Browser environment - use fetch with timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout\n        \n        try {\n          const response = await fetch('/public/content/content-index.bin', {\n            signal: controller.signal\n          });\n          clearTimeout(timeoutId);\n          \n          if (!response.ok) {\n            throw new Error(`Failed to load content index: ${response.status} ${response.statusText}`);\n          }\n          contentIndexData = await response.json() as ContentIndex;\n        } catch (fetchError) {\n          clearTimeout(timeoutId);\n          throw fetchError;\n        }\n      }\n      \n      this.contentIndex = contentIndexData;\n      this.isLoaded = true;\n      this.loadingPromise = null;\n      \n      // Clear any previous retry attempts on success\n      errorHandlingService.clearRetryAttempts('contentService_loadIndex');\n      \n      console.log('Content index loaded:', {\n        version: this.contentIndex.version,\n        categories: this.contentIndex.metadata.categories.length,\n        entries: this.contentIndex.metadata.totalEntries\n      });\n      \n      return this.contentIndex;\n    } catch (error: unknown) {\n      this.loadingPromise = null;\n      \n      // Handle error with fallback\n      const errorResult = await errorHandlingService.handleContentServiceError(\n        'loadIndex', \n        error, \n        { operation: 'loadContentIndex' }\n      ) as ErrorResult;\n      \n      if (errorResult.useFallback) {\n        // Use fallback structure\n        this.contentIndex = {\n          metadata: {\n            categories: errorResult.fallbackData || [],\n            subcategories: {}\n          },\n          entries: [],\n          version: 'fallback',\n          timestamp: Date.now(),\n          fallback: true\n        };\n        this.isLoaded = true;\n        \n        console.warn('Using fallback content structure due to loading error');\n        return this.contentIndex;\n      }\n      \n      // Re-throw if we can't use fallback\n      throw error;\n    }\n  }\n\n  /**\n   * Get all top-level categories with error handling\n   * @returns {Promise<string[]>} Array of category names\n   */\n  async getCategories(): Promise<string[]> {\n    const cacheKey = 'getCategories';\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey);\n    }\n\n    if (this.cache.has(cacheKey + '-promise')) {\n      return this.cache.get(cacheKey + '-promise');\n    }\n\n    const promise = (async (): Promise<string[]> => {\n      try {\n        const contentIndex = await this.loadContentIndex();\n        const categories = contentIndex.metadata.categories || [];\n        this.cache.set(cacheKey, categories);\n        return categories;\n      } catch (error: unknown) {\n        const errorResult = await errorHandlingService.handleContentServiceError(\n          'getCategories',\n          error\n        ) as ErrorResult;\n        return errorResult.fallbackData || [];\n      } finally {\n        this.cache.delete(cacheKey + '-promise');\n      }\n    })();\n\n    this.cache.set(cacheKey + '-promise', promise);\n    return promise;\n  }\n\n  /**\n   * Get subcategories for a specific category with error handling\n   * @param {string} category - The category name\n   * @returns {Promise<string[]>} Array of subcategory names\n   */\n  async getSubcategories(category: string): Promise<string[]> {\n    const cacheKey = `getSubcategories-${category}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey);\n    }\n\n    if (this.cache.has(cacheKey + '-promise')) {\n      return this.cache.get(cacheKey + '-promise');\n    }\n\n    const promise = (async (): Promise<string[]> => {\n      try {\n        const contentIndex = await this.loadContentIndex();\n        const subcategories = contentIndex.metadata.subcategories[category] || [];\n        this.cache.set(cacheKey, subcategories);\n        return subcategories;\n      } catch (error: unknown) {\n        const errorResult = await errorHandlingService.handleContentServiceError(\n          'getSubcategories',\n          error,\n          { category }\n        ) as ErrorResult;\n        return errorResult.fallbackData || [];\n      } finally {\n        this.cache.delete(cacheKey + '-promise');\n      }\n    })();\n\n    this.cache.set(cacheKey + '-promise', promise);\n    return promise;\n  }\n\n  /**\n   * Get replacement thoughts filtered by category, subcategory, and intensity level with error handling\n   * @param {string} category - The category name\n   * @param {string} subcategory - The subcategory name (optional)\n   * @param {number} maxIntensity - Maximum intensity level (optional)\n   * @returns {Promise<string[]>} Array of replacement thoughts\n   */\n  async getReplacementThoughts(category: string, subcategory: string | null = null, maxIntensity: number = 10): Promise<string[]> {\n    const cacheKey = `getReplacementThoughts-${category}-${subcategory}-${maxIntensity}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey);\n    }\n\n    if (this.cache.has(cacheKey + '-promise')) {\n      return this.cache.get(cacheKey + '-promise');\n    }\n\n    const promise = (async (): Promise<string[]> => {\n      try {\n        const contentIndex = await this.loadContentIndex();\n\n        const replacementThoughts: string[] = [];\n\n        // Find entries that match the category\n        const matchingEntries = contentIndex.entries.filter(entry => {\n        if (!isValidEntry(entry)) return false;\n          if (entry.category !== category) return false;\n          if (subcategory && !entry.subcategories.includes(subcategory)) return false;\n          return true;\n        });\n\n        // Extract replacement thoughts from matching entries\n        for (const entry of matchingEntries) {\n          if (entry.replacementThoughts && Array.isArray(entry.replacementThoughts)) {\n            replacementThoughts.push(...entry.replacementThoughts);\n          }\n        }\n\n        // For now, we don't have intensity levels in the data structure\n        // This could be enhanced in the future\n        this.cache.set(cacheKey, replacementThoughts);\n        return replacementThoughts;\n      } catch (error: unknown) {\n        const errorResult = await errorHandlingService.handleContentServiceError(\n          'getReplacementThoughts',\n          error,\n          { category, subcategory, maxIntensity }\n        ) as ErrorResult;\n        return errorResult.fallbackData || [];\n      } finally {\n        this.cache.delete(cacheKey + '-promise');\n      }\n    })();\n\n    this.cache.set(cacheKey + '-promise', promise);\n    return promise;\n  }\n\n  /**\n   * Get mining prompts for a specific category and type with error handling\n   * @param {string} category - The category name\n   * @param {string} type - The prompt type ('neutralize', 'commonGround', 'dataExtraction')\n   * @returns {Promise<string[]>} Array of mining prompts\n   */\n  async getMiningPrompts(category: string, type: string): Promise<string[]> {\n    const cacheKey = `getMiningPrompts-${category}-${type}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey);\n    }\n\n    if (this.cache.has(cacheKey + '-promise')) {\n      return this.cache.get(cacheKey + '-promise');\n    }\n\n    const promise = (async (): Promise<string[]> => {\n      try {\n        const contentIndex = await this.loadContentIndex();\n\n        const prompts: string[] = [];\n\n        // Find entries that match the category\n        const matchingEntries = contentIndex.entries.filter(entry =>\n          isValidEntry(entry) && entry.category === category\n        );\n\n        // Extract mining prompts from matching entries\n        for (const entry of matchingEntries) {\n          if (entry.miningPrompts && entry.miningPrompts[type]) {\n            prompts.push(...entry.miningPrompts[type]);\n          }\n        }\n\n        this.cache.set(cacheKey, prompts);\n        return prompts;\n      } catch (error: unknown) {\n        const errorResult = await errorHandlingService.handleContentServiceError(\n          'getMiningPrompts',\n          error,\n          { category, type }\n        ) as ErrorResult;\n        return errorResult.fallbackData || [];\n      } finally {\n        this.cache.delete(cacheKey + '-promise');\n      }\n    })();\n\n    this.cache.set(cacheKey + '-promise', promise);\n    return promise;\n  }\n\n  /**\n   * Search content by text query\n   * @param query - Search query\n   * @param category - Optional category filter\n   * @returns Array of matching content chunks\n   */\n  async searchContent(query: string, category: string | null = null): Promise<SearchResult[]> {\n    const contentIndex = await this.loadContentIndex();\n    \n    const results: SearchResult[] = [];\n    const queryLower = query.toLowerCase();\n    \n    for (const entry of contentIndex.entries) {\n      if (category && entry.category !== category) continue;\n      \n      // Search through chunks\n      for (const chunk of entry.chunks || []) {\n        if (chunk.text.toLowerCase().includes(queryLower)) {\n          results.push({\n            text: chunk.text,\n            category: entry.category,\n            subcategories: entry.subcategories,\n            metadata: chunk.metadata,\n            relevance: this.calculateRelevance(chunk.text, query)\n          });\n        }\n      }\n    }\n\n    // Sort by relevance\n    return results.sort((a, b) => b.relevance - a.relevance);\n  }\n\n  /**\n   * Simple relevance calculation\n   * @private\n   * @param text - The content text\n   * @param query - The search query\n   * @returns Relevance score\n   */\n  private calculateRelevance(text: string, query: string): number {\n    const textLower = text.toLowerCase();\n    const queryLower = query.toLowerCase();\n    \n    // Count exact matches\n    const exactMatches = (textLower.match(new RegExp(queryLower, 'g')) || []).length;\n    \n    // Boost shorter texts with matches\n    const lengthBoost = 1 / (text.length / 100);\n    \n    return exactMatches + lengthBoost;\n  }\n\n  /**\n   * Get content statistics\n   * @returns Statistics about the content index\n   */\n  async getStats(): Promise<ContentStats> {\n    const contentIndex = await this.loadContentIndex();\n    \n    return {\n      version: contentIndex.version,\n      timestamp: contentIndex.timestamp,\n      categories: contentIndex.metadata.categories.length,\n      totalEntries: contentIndex.metadata.totalEntries,\n      totalChunks: contentIndex.metadata.totalChunks,\n      subcategoriesPerCategory: Object.entries(contentIndex.metadata.subcategories)\n        .map(([cat, subs]) => ({ category: cat, subcategories: subs.length }))\n    };\n  }\n}\n\n// Export singleton instance\nexport const contentSearchService = new ContentSearchService();\nexport default contentSearchService;"],"file":"assets/ContentSearchService-DqsTnI7q.js"}